import { isFunction } from 'lodash';
import React from 'react';
import ReactDomServer from 'react-dom/server';
import { FluxibleComponent } from 'fluxible-addons-react';
import Html from '../main/components/common/Html';

const debug = require('debug')('app:utils/fluxible');

/**
 * @method createContext
 * this method will be used on CLIENT SIDE ONLY,
 * to create proper context with different dehydratedState,
 * as context on client-side depends on dehydrated state
 *
 * @param app {Class} Fluxible class
 * @param dehydratedState
 * @param options {Object} the option object to be passed into app.createContext
 * @param options.req {Object} Express request object
 * @param options.res {Object} Express response object
 * @param options.config {Object} config object
 * @param cb {Function}
 */
export function createContext(app, state, options, cb) {
  if (!state) {
    debug('universal javascript disabled, creating new context');
    const context = app.createContext(options);
    cb(null, context);
    return;
  }

  debug('universal javascript enabled, rehydrating app context');
  app.rehydrate(state, cb);
}

/**
 * @method createHtmlElement
 *
 * @param config {String} serialized react-application-related configs
 * @param state {String} serialized state to be rehydrated
 * @param markupElement {ReactElement} the rendered ReactElement as output
 * @returns {ReactElement}
 */
export function createHtmlElement(config, state, markupElement) {
  const props = {
    config,
    state,
    markup: markupElement && ReactDomServer.renderToString(markupElement),
  };
  const element = React.createElement(Html, props);
  return element;
}

/**
 * @method createMarkupElement
 * to create the toppest ReactElement for a Fluxible application.
 * This can be used in both client and server
 *
 * @param context Fluxible context
 * @param children {ReactElement} ReactElement as children, either
 * RoutingContext on server-side or Router Element on client-side
 * @returns {ReactElement}
 * @throws will throw error if context argument is not provided
 * @throws will throw error if context is not Fluxible context
 * @throws will throw error if children argument is not provided
 * @see {@link https://github.com/yahoo/fluxible/tree/master/examples/react-router}
 */
export function createMarkupElement(context, children) {
  if (!context) {
    throw new Error('Fluxible context is missing');
  }

  if (!isFunction(context.getComponentContext)) {
    throw new Error('context does not contain getComponentContext method');
  }

  if (!children) {
    throw new Error('react-router children element is missing');
  }

  const element = React.createElement(
    FluxibleComponent,
    { context: context.getComponentContext() },
    children,
  );

  return element;
}

/**
 * @method getRedirectPath
 * to get the redirect path generated by react-router
 *
 * @param redirectLocation {Object} the object returned by react-router if
 * @param redirectLocation.pathname {String}
 * @param redirectLocation.search {String}
 *
 * @returns {String} redirect path
 * @see {@link https://github.com/reactjs/react-router/blob/master/docs%2Fguides%2FServerRendering.md}
 */
export function getRedirectPath(redirectLocation) {
  const { pathname, search } = redirectLocation;
  return `${pathname}${search}`;
}

/**
 * @method prependDocType
 * to prepend the html DOCTYPE string to a html string which is rendered
 * as string from jsx syntax which does not allow DOCTYPE
 *
 * @param html {String} html markup string
 * @returns {String}
 */
export function prependDocType(html) {
  return `<!DOCTYPE html>${html}`;
}
